<!DOCTYPE html>
<html lang="zh-cn"><head><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-3XR6QD9MQ2"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3XR6QD9MQ2")</script><meta charset="utf-8"/><meta content="MlCbTFwi8qVmMCmDnlISOYdFqFcBTIA3hdWJIev8ljg" name="google-site-verification"/><meta content="IE=edge,chrome=1" http-equiv="x-ua-compatible"/><meta content="width=device-width,initial-scale=1" name="viewport"/><meta content="Sswin" name="author"/><title>Linux常用命令大全 ｜ SSWIN</title><meta content=" 本文记录了Linux操作系统中常用的命令以及对应参数，方便使用的时候进行查询
" name="description"/><meta content="Linux,技术,转载" name="keywords"/><meta content="summary" name="twitter:card"/><meta content="/post/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/" name="twitter:site"/><meta content="Linux常用命令大全" name="twitter:creator"/><meta content="Linux常用命令大全" name="twitter:title"/><meta content=" 本文记录了Linux操作系统中常用的命令以及对应参数，方便使用的时候进行查询
" name="twitter:description"/><meta content="https://zozo.wssss.one/images/favicon.ico" name="twitter:image"/><meta content="Linux常用命令大全" property="og:title"/><meta content="/post/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/" property="og:url"/><meta content="https://zozo.wssss.one/images/favicon.ico" property="og:image"/><meta content=" 本文记录了Linux操作系统中常用的命令以及对应参数，方便使用的时候进行查询
" name="og:description"/><meta content="Linux常用命令大全" property="og:site_name"/><meta content="article" property="og:type"/><meta content="" property="og:article:author"/><link href="https://zozo.wssss.one/images/favicon.ico" rel="shortcut icon"/><link href="https://zozo.wssss.one/css/normalize.css" media="screen" rel="stylesheet" type="text/css"/><link href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" media="screen" rel="stylesheet" type="text/css"/><link href="https://zozo.wssss.one/css/zozo.css" media="screen" rel="stylesheet" type="text/css"/><link href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" media="screen" rel="stylesheet" type="text/css"/><link href="https://zozo.wssss.one/css/highlight.css" media="screen" rel="stylesheet" type="text/css"/><script src="https://unpkg.com/@waline/client@v2/dist/waline.js"></script>
<link href="https://unpkg.com/@waline/client@v2/dist/waline.css" rel="stylesheet"/></head><body><div class="main animate__animated animate__fadeInDown"><div class="nav_container animated fadeInDown"><div class="site_nav" id="site_nav"><ul><li><a href="/">主页</a></li><li><a href="/posts/">归档</a></li><li><a href="/tags/">标签</a></li><li><a href="https://blogroll.wssss.one/">链接</a></li><li><a href="/about/">关于</a></li></ul></div><div class="menu_icon"><a id="menu_icon"><i class="ri-menu-line"></i></a></div></div><div class="header animated fadeInDown"><div class="site_title_container"><div class="site_title"><a href="https://zozo.wssss.one/"><img alt="SSWIN" src="https://zozo.wssss.one//images/favicon.ico" style="border-radius:50px;width:100"/></a></div><div class="description"><p class="sub_title">放进时光蛋里。</p><div class="my_socials"><a href="mailto://me@wssss.one" target="_blank" title="mail"><i class="ri-mail-fill"></i></a>
<a href="http://sms%3A%2F%2F18336983040" target="_blank" title="phone"><i class="ri-phone-fill"></i></a>
<a href="//t.me/karl_s_bot" target="_blank" title="telegram"><i class="ri-telegram-fill"></i></a>
<a href="https://zozo.wssss.one/index.xml" target="_blank" title="rss" type="application/rss+xml"><i class="ri-rss-fill"></i></a></div></div></div></div><div class="content"><div class="post_page"><div class="post animate__animated animate__fadeInDown"><div class="post_title post_detail_title"><h2><a href="/post/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/">Linux常用命令大全</a></h2><span class="date">2022.09.06</span></div><div class="post_content markdown"><blockquote><p>本文记录了Linux操作系统中常用的命令以及对应参数，方便使用的时候进行查询</p></blockquote><h1 id="前言">前言</h1><p>本文记录了Linux操作系统中常用的命令以及对应参数，方便使用的时候进行查询，主要参考<code>541137 Linux命令行与shell脚本编程大全.第3版</code>一书，后面还有许多高级的内容，但日常的linux使用下面涉及的已经足够。本文的正确打开方式是作为字典式的命令查询，不建议将这些命令一一背住，只需了解基础的几个就好。</p><blockquote><p>部分复杂内容添加了配图方便理解，也可以前往我的<a href="https://www.gentlecp.com/articles/676.html">个人博客</a>阅读原文</p></blockquote><h1 id="常用命令">常用命令</h1><h2 id="查看文件ls命令">查看文件ls命令</h2><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">ls -F  # 用于区分文件和目录
</span></span><span class="line"><span class="cl">ls -a  # 显示隐藏目录和文件
</span></span><span class="line"><span class="cl">ls -R  # 递归显示文件和目录
</span></span><span class="line"><span class="cl">ls -l  # 显示长列表，包含更多信息
</span></span><span class="line"><span class="cl">ls -l file_name  
</span></span><span class="line"><span class="cl"># 过滤显示，可以用?代替一个字符，*代替零个或多个
</span></span><span class="line"><span class="cl">[a-z]表示a-z任一个，！后跟字符表示除这个字符外，！需放置在[]中
</span></span></code></pre></div><h2 id="创建文件touch命令">创建文件touch命令</h2><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">touch file_name # 创建一个文件，若无则创建，若有则修改文件的修改时间
</span></span><span class="line"><span class="cl">touch -a file_name # 只修改文件的访问时间
</span></span></code></pre></div><p>要查看访问时间用以下命令</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">ls -l --time=atime
</span></span></code></pre></div><h2 id="复制文件">复制文件</h2><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">cp source destination  # 如果目标文件已存在会强制覆盖
</span></span><span class="line"><span class="cl">cp -i source destination  # 询问是否覆盖
</span></span><span class="line"><span class="cl">cp file dir/  # 如果不指定拷贝的文件，只是复制到dir目录下，需要加上/
</span></span><span class="line"><span class="cl">cp -R dir1/ dir2  # 递归复制文件夹
</span></span></code></pre></div><h2 id="链接文件">链接文件</h2><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">ln -s source destination  # 符号链接，结果：destination-&gt;source,相当于快捷方式
</span></span><span class="line"><span class="cl">ln source destination  # 硬链接，两个相同的文件
</span></span></code></pre></div><h2 id="移动文件">移动文件</h2><p>类似copy</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">mv source destination  # 可以重命名
</span></span></code></pre></div><h2 id="删除文件">删除文件</h2><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">rm -i file  # 建议添加-i询问是否删除，以免误删，因为不能撤销
</span></span><span class="line"><span class="cl">rm -r dir/  # 删除文件夹
</span></span><span class="line"><span class="cl">加f参数是强制删除，慎用！！
</span></span></code></pre></div><h2 id="查看文件类型">查看文件/类型</h2><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">file file_name  # 查看文件内部，给出文件类型，包括编码方式
</span></span><span class="line"><span class="cl">file dir  # 区分目录
</span></span><span class="line"><span class="cl">cat file_name  # 查看文件内容
</span></span><span class="line"><span class="cl">cat -n file_name  # 给所有行加上行号
</span></span><span class="line"><span class="cl">cat -b file_name  # 给有文本的行加上行号
</span></span><span class="line"><span class="cl">more file_name  # 查看文件内容，包含文件所属位置，在每页数据停下
</span></span><span class="line"><span class="cl">tail file_name  # 显示文件最后几行，默认10行
</span></span><span class="line"><span class="cl">tail -n 3 file_name  # 显示最后3行，也可以直接把n换成3
</span></span><span class="line"><span class="cl">tail -f file_name  # 动态查看最后几行，如果有其他进程对文件修改，则会动态加载，用于监视系统日志
</span></span><span class="line"><span class="cl">head file_name  # 显示开头几行，默认10行，除了-f其余属性与tail相同
</span></span></code></pre></div><h2 id="linux命令行图谱">Linux命令行图谱</h2><p>[![img](https://img-blog.csdnimg.cn/20200302133009486.png#pic_center =500x250)](<a href="https://img-blog.csdnimg.cn/20200302133009486.png#pic_center">https://img-blog.csdnimg.cn/20200302133009486.png#pic_center</a> =500x250)</p><h1 id="进程操作">进程操作</h1><p>本章比较复杂，添加了图片做说明</p><h2 id="查看进程">查看进程</h2><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">ps -ef  # 显示系统上运行的所有进程，-e指定显示所有运行在系统上的进程，-f扩展了输出
</span></span></code></pre></div><p><a href="https://img-blog.csdnimg.cn/2020030213303494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dlbnRsZUNQ,size_16,color_FFFFFF,t_70"><img alt="img" src="https://img-blog.csdnimg.cn/2020030213303494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dlbnRsZUNQ,size_16,color_FFFFFF,t_70"/></a></p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">UID</td><td style="text-align:center">启动这些进程的用户</td></tr><tr><td style="text-align:center">PID</td><td style="text-align:center">进程ID</td></tr><tr><td style="text-align:center">PPID</td><td style="text-align:center">父进程的进程ID</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">进程生命周期中的CPU利用率</td></tr><tr><td style="text-align:center">STIME</td><td style="text-align:center">进程启动时的系统时间</td></tr><tr><td style="text-align:center">TTY</td><td style="text-align:center">进程启动时的终端设备</td></tr><tr><td style="text-align:center">TIME</td><td style="text-align:center">运行进程需要的累计CPU时间</td></tr><tr><td style="text-align:center">CMD</td><td style="text-align:center">启动的程序名称</td></tr></tbody></table><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">ps -l  # 产生一个长格式的输出
</span></span></code></pre></div><p><a href="https://img-blog.csdnimg.cn/2020030213305614.png"><img alt="img" src="https://img-blog.csdnimg.cn/2020030213305614.png"/></a></p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">F</td><td style="text-align:center">内核分配给进程的系统标记</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">进程的状态（O：运行；S：休眠；R：可运行,正等待运行；Z：僵化,进程已结束但父进程已不存在；T:停止）</td></tr><tr><td style="text-align:center">PRI</td><td style="text-align:center">进程的优先级</td></tr><tr><td style="text-align:center">NI</td><td style="text-align:center">谦让度值用来参与决定优先级</td></tr><tr><td style="text-align:center">ADDR</td><td style="text-align:center">进程的内存地址</td></tr><tr><td style="text-align:center">SZ</td><td style="text-align:center">假如进程被换出，所需交换空间的大致大小</td></tr><tr><td style="text-align:center">WCHAN</td><td style="text-align:center">进程休眠的内核函数的地址</td></tr></tbody></table><h2 id="实时监测进程">实时监测进程</h2><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">top  
</span></span><span class="line"><span class="cl">top -l
</span></span></code></pre></div><h2 id="结束进程">结束进程</h2><p>kill命令结束进程</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ps -l  # 通常先用ps命令查看进程ID
</span></span><span class="line"><span class="cl">kill PID  # 根据PID结束进程
</span></span></code></pre></div><p>killall命令结束进程</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">killall http*  # 结束所有以http开头的进程，允许通过进程名结束进程
</span></span></code></pre></div><h1 id="磁盘空间">磁盘空间</h1><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">df -h  # 查看磁盘使用情况
</span></span></code></pre></div><p><a href="https://img-blog.csdnimg.cn/2020030213311057.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dlbnRsZUNQ,size_16,color_FFFFFF,t_70"><img alt="img" src="https://img-blog.csdnimg.cn/2020030213311057.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dlbnRsZUNQ,size_16,color_FFFFFF,t_70"/></a></p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">du  # 显示当前目录下所有的文件、目录和子目录的磁盘使用情况
</span></span><span class="line"><span class="cl">du -c # 显示所有已列出文件总的大小
</span></span><span class="line"><span class="cl">du -h # 人性化显示
</span></span></code></pre></div><h1 id="处理数据文件">处理数据文件</h1><h2 id="排序数据">排序数据</h2><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">sort file_name  # 按默认的语言排序规则对文本文件数据排序
</span></span><span class="line"><span class="cl">sort -n file_name  # 按数字排序
</span></span><span class="line"><span class="cl">sort -M file_name  # 按三字符月份排序，适用于 Jan，Feb这些打头的
</span></span><span class="line"><span class="cl">sort -f file_name  # 忽略大小写排序
</span></span></code></pre></div><h2 id="搜索数据">搜索数据</h2><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">grep [options] pattern [file] # 在文件中查找包含匹配指定模式的字符的行
</span></span><span class="line"><span class="cl">grep t file1  # 在file1中找t开头的行
</span></span><span class="line"><span class="cl">grep -v t file1  # 在file1中找不以t开头的行
</span></span><span class="line"><span class="cl">grep -n t file1  # 显示行号
</span></span><span class="line"><span class="cl">grep -c t file1  # 匹配的数量
</span></span><span class="line"><span class="cl">grep [tf] file1  # 在file1中找t或f开头的行，这里也可以用正则表达式
</span></span></code></pre></div><h2 id="压缩数据">压缩数据</h2><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">gzip file  # 压缩文件
</span></span><span class="line"><span class="cl">gzip file*  # 压缩所有匹配的文件
</span></span><span class="line"><span class="cl">gunzip file.gz  # 解压文件 
</span></span></code></pre></div><h2 id="归档数据">归档数据</h2><p>相比与gzip，tar命令用的更多</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">tar function [options] object1 object2 ...
</span></span></code></pre></div><ul><li><strong>tar命令的功能</strong></li></ul><table><thead><tr><th style="text-align:center">功能</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-A</td><td style="text-align:center">将一个已有归档文件追加到另一个已有归档文件</td></tr><tr><td style="text-align:center">-c</td><td style="text-align:center">创建一个新的tar归档文件</td></tr><tr><td style="text-align:center">-d</td><td style="text-align:center">检查归档文件和文件系统的不同之处</td></tr><tr><td style="text-align:center">-r</td><td style="text-align:center">追加文件到已有tar归档文件末尾</td></tr><tr><td style="text-align:center">-t</td><td style="text-align:center">列出已有tar归档文件的内容</td></tr><tr><td style="text-align:center">-u</td><td style="text-align:center">将比tar归档文件中已有的同名文件新的文件追加到该tar归档文件中，简单来说就是更新文件内容</td></tr><tr><td style="text-align:center">-x</td><td style="text-align:center">从已有tar归档文件中提取文件</td></tr></tbody></table><ul><li><strong>tar命令的选项</strong></li></ul><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-C</td><td style="text-align:center">切换到指定目录</td></tr><tr><td style="text-align:center">-f file</td><td style="text-align:center">输出结果到文件或设备file</td></tr><tr><td style="text-align:center">-j</td><td style="text-align:center">将输出重定向给bzip2来压缩内容</td></tr><tr><td style="text-align:center">-p</td><td style="text-align:center">保留所有文件权限</td></tr><tr><td style="text-align:center">-v</td><td style="text-align:center">在处理文件时显示文件</td></tr><tr><td style="text-align:center">-z</td><td style="text-align:center">将输出重定向给gzip命令来压缩内容</td></tr></tbody></table><p>常用tar命令结构：</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">tar -cvf test.tar test1/ test2/  # 创建名为test.tar的归档文件，含有test1和test2目录内容 
</span></span><span class="line"><span class="cl">tar -tf test.tar  # 列出tar文件test.tar的内容（并不提取文件）
</span></span><span class="line"><span class="cl">tar -xvf test.tar  # 提取test.tar内容
</span></span><span class="line"><span class="cl">tar -zxvf  test.tgz  # 解压以.tgz结尾的压缩文件
</span></span></code></pre></div><h1 id="linux环境变量">Linux环境变量</h1><p>环境变量的定义：
bash shell 用环境变量的特性来存储有关shell会话和工作环境的信息，允许我们在内存中存储数据，以便程序或shell中运行的脚本能够轻松访问到它们。</p><h2 id="全局环境变量">全局环境变量</h2><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">printenv  # 查看全局变量
</span></span></code></pre></div><p><a href="https://img-blog.csdnimg.cn/20200302133133279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dlbnRsZUNQ,size_16,color_FFFFFF,t_70"><img alt="img" src="https://img-blog.csdnimg.cn/20200302133133279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dlbnRsZUNQ,size_16,color_FFFFFF,t_70"/></a></p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">printenv HOME  # 显示某个环境变量
</span></span><span class="line"><span class="cl">echo $HOME  # 显示某个环境变量，需要加$，且加了$可以作为命令行参数
</span></span></code></pre></div><p>设置全局环境变量</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">export variable  # variable是一个局部环境变量，相当于将局部变为全局
</span></span></code></pre></div><p>永久设置全局环境变量：
在$HOME/.bashrc 中定义全局环境变量，例如将alias设置放在.bashrc启动文件中 ，或者存储在.profile文件中</p><h2 id="局部环境变量">局部环境变量</h2><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">set # 显示某个特定进程设置的环境变量
</span></span></code></pre></div><p>设置局部环境变量</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">echo $variable
</span></span><span class="line"><span class="cl">variable=test  # 注意中间不能有空格
</span></span><span class="line"><span class="cl">echo $variable
</span></span></code></pre></div><p>删除环境变量</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">unset variable  # 注意这时候不加$
</span></span></code></pre></div><h2 id="path环境变量">PATH环境变量</h2><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">PATH=$PATH:new_dir  # 添加new_dir到PATH中，此修改仅持续到退出或重启系统
</span></span></code></pre></div><p>登录shell后，shell会从以下5个不同的启动文件中读取命令：</p><table><thead><tr><th style="text-align:left">文件名</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">/etc/profile</td><td style="text-align:left">系统上默认shell启动文件，不分用户。 ubantu版本中涉及/etc/bash.bashrc,该文件包含了系统环境变量，但CentOS版本中没有 文件中主要for循环迭代启动/etc/profile.d目录下的文件</td></tr><tr><td style="text-align:left">$HOME/.bash_profile</td><td style="text-align:left">检查HOME目录是否有.bashrc,若有，则执行.bashrc里的命令，如果存在则忽略剩下的启动文件</td></tr><tr><td style="text-align:left">$HOME/.bashrc</td><td style="text-align:left">存放启动shell时会执行的命令</td></tr><tr><td style="text-align:left">$HOME/.bash_login</td><td style="text-align:left">功能与bash_profile类似，但执行优先级晚</td></tr><tr><td style="text-align:left">$HOME/.profile</td><td style="text-align:left">同上</td></tr></tbody></table><h1 id="linux文件权限">Linux文件权限</h1><h2 id="添加新用户">添加新用户</h2><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">useradd &lt;user&gt;  # 添加一个新用户 
</span></span></code></pre></div><p>添加用户之后该用户还没有密码，需要通过passwd命令给该用户添加密码</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">passwd &lt;user&gt;  # 输入命令后根据提示输入密码
</span></span></code></pre></div><p>通过命令创建的用户存放在/etc/passwd文件中</p><h2 id="删除用户">删除用户</h2><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">userdel &lt;user&gt;  # 只会删除/etc/passwd文件中的用户信息，不删除系统中属于该用户的任何文件
</span></span><span class="line"><span class="cl">userdel -r &lt;user&gt;  # 删除该用户在home中的文件和该用户
</span></span></code></pre></div><h2 id="修改用户">修改用户</h2><ul><li><strong>用户账户修改工具</strong></li></ul><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">usermod</td><td style="text-align:left">修改用户账户字段，还可以指定主要组以及附加组的所属关系</td></tr><tr><td style="text-align:left">passwd</td><td style="text-align:left">修改已有用户的密码</td></tr><tr><td style="text-align:left">chpasswd</td><td style="text-align:left">从文件中读取登录名密码对，并更新密码</td></tr><tr><td style="text-align:left">chage</td><td style="text-align:left">修改密码的过期日期</td></tr><tr><td style="text-align:left">chfn</td><td style="text-align:left">修改用户账户的备注信息</td></tr><tr><td style="text-align:left">chsh</td><td style="text-align:left">修改用户账户的默认登录shell</td></tr></tbody></table><ul><li>usermod的参数</li></ul><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">-c</td><td style="text-align:left">修改备注字段</td></tr><tr><td style="text-align:left">-e</td><td style="text-align:left">修改过期日期</td></tr><tr><td style="text-align:left">-g</td><td style="text-align:left">修改默认的登录组</td></tr><tr><td style="text-align:left">-l</td><td style="text-align:left">修改用户账户的登录名</td></tr><tr><td style="text-align:left">-L</td><td style="text-align:left">锁定账户，使用户无法登录</td></tr><tr><td style="text-align:left">-p</td><td style="text-align:left">修改账户密码</td></tr><tr><td style="text-align:left">-U</td><td style="text-align:left">接触锁定，使账户能够登录</td></tr></tbody></table><h2 id="linux组">Linux组</h2><p>就是一堆用户共享同一权限，用户组信息保存在/etc/group文件中</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">groupadd group  # 创建新组
</span></span></code></pre></div><p>更多用户组命令由于涉及不多，不一一列举，以后补上</p><h2 id="文件权限">文件权限</h2><p>理解ls -l列出的文件权限字段含义</p><p><a href="https://img-blog.csdnimg.cn/20200302133206168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dlbnRsZUNQ,size_16,color_FFFFFF,t_70"><img alt="img" src="https://img-blog.csdnimg.cn/20200302133206168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dlbnRsZUNQ,size_16,color_FFFFFF,t_70"/></a></p><p>第一个字段是描述文件和目录权限的编码：
-:文件
d:目录
l:链接
c:字符型设备
b:块设备
n:网络设备
接着是3组字符的编码：
r:可读
w:可写
x:可执行
三组分别是对象属主，对象数组，其他用户</p><ul><li><strong>默认权限</strong>
默认权限由umask命令设置，权限的赋予采用八进制，下表记录了常用的权限对应的八进制值</li></ul><table><thead><tr><th style="text-align:center">权限</th><th style="text-align:center">二进制</th><th style="text-align:center">八进制</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">—-</td><td style="text-align:center">000</td><td style="text-align:center">0</td><td style="text-align:center">无权限</td></tr><tr><td style="text-align:center">—x</td><td style="text-align:center">001</td><td style="text-align:center">1</td><td style="text-align:center">只有执行权限</td></tr><tr><td style="text-align:center">-w-</td><td style="text-align:center">010</td><td style="text-align:center">2</td><td style="text-align:center">只有写权限</td></tr><tr><td style="text-align:center">-wx</td><td style="text-align:center">011</td><td style="text-align:center">3</td><td style="text-align:center">写+执行</td></tr><tr><td style="text-align:center">r—</td><td style="text-align:center">100</td><td style="text-align:center">4</td><td style="text-align:center">只读</td></tr><tr><td style="text-align:center">r-x</td><td style="text-align:center">101</td><td style="text-align:center">5</td><td style="text-align:center">读+执行</td></tr><tr><td style="text-align:center">rw-</td><td style="text-align:center">110</td><td style="text-align:center">6</td><td style="text-align:center">读写</td></tr><tr><td style="text-align:center">rwx</td><td style="text-align:center">111</td><td style="text-align:center">7</td><td style="text-align:center">全部权限</td></tr></tbody></table><p>umask值是个掩码，会屏蔽不想授予安全级别的权限
例如umask = 026 ，则目录的默认权限是 777-026 = 751，文件的默认权限是666-026 = 640
umask设置在/etc/prpfile启动文件中</p><ul><li><strong>改变权限</strong></li></ul><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">chmod 777 file  # 赋予file的所有权限给所有人
</span></span><span class="line"><span class="cl">chmod +x file   # 给所有人添加file的执行权限
</span></span><span class="line"><span class="cl">chmod o+x file  
</span></span></code></pre></div><p>chmod [ugoa] [+-=] [rxw] file
这种形式允许针对用户或组，添加修改权限，u代表用户，g代表组，o代表其他，a代表上述所有</p><h1 id="安装软件程序">安装软件程序</h1><h2 id="基于debian系统">基于Debian系统</h2><p>采用dpkg命令直接和Linux系统上的PMS（package management system 包管理系统）交互，用来安装、管理和删除软件包
包含在此PMS的其他工具有：
1、apt-get
2、apt-cache
3、aptitude</p><ul><li><p>用apt-get安装软件包</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">apt-get search package_name  # 查找软件包
</span></span><span class="line"><span class="cl">apt-get install package_name  # 安装软件包
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apt-get safe-upgrade  # 更新软件包
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">apt-get remove package_name  # 卸载软件,只删除软件包
</span></span><span class="line"><span class="cl">apt-get purge package_name  # 删除软件包和相关的数据和配置文件
</span></span></code></pre></div></li></ul><p>ubantu下统一了apt命令，可以将上述全替换成apt</p><p><strong>dpkg安装.deb包</strong></p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">dpkg -i jdk-XXX_linux-x64_bin.deb
</span></span></code></pre></div><p>配置文件路径：</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">/etc/apt/sources.list
</span></span></code></pre></div><p>以搬瓦工的ubantu系统服务器为例
<a href="https://img-blog.csdnimg.cn/2020030213325689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dlbnRsZUNQ,size_16,color_FFFFFF,t_70"><img alt="img" src="https://img-blog.csdnimg.cn/2020030213325689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dlbnRsZUNQ,size_16,color_FFFFFF,t_70"/></a></p><h2 id="72-基于red-hat系统">7.2 基于Red Hat系统</h2><p>采用rpm命令，常见的前端工具有：
1、yum：在Red Hat 和Fedora使用
2、urpm： 在Mandriva使用
3、zypper：在openSUSE使用
由于yum使用较多，以yum为例</p><ul><li><p><strong>用yum安装软件包</strong></p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">yum list installed  # 列出已安装的包
</span></span><span class="line"><span class="cl">yum list installed &gt; installed_software  # 将已安装包的列表重定向到一个文件中  
</span></span><span class="line"><span class="cl">yum install package_name  # 安装软件
</span></span><span class="line"><span class="cl">yum localinstall package_name.rpm  # 本地安装rpm安装包
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">yum list updates  # 列出所有已安装包的可用更新
</span></span><span class="line"><span class="cl">yum update packet_name  # 跟新指定包
</span></span><span class="line"><span class="cl">yum update  # 对更新列表中所有包进行更新
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">yum remove package_name  # 只删除软件包而保留配置文件和数据文件
</span></span><span class="line"><span class="cl">yum erase package_name  #  删除软件和它所有的文件
</span></span></code></pre></div></li></ul><p><strong>用rpm安装rpm包</strong></p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">rpm -i jdk-XXX_linux-x64_bin.rpm
</span></span></code></pre></div><p><strong>处理损坏包依赖关系</strong></p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">yum clean all  # 清除损坏依赖包
</span></span><span class="line"><span class="cl">yum update 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">yum deplist package_name  # 显示该包的所有包依赖关系
</span></span></code></pre></div><p>配置文件路径</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">/etc/yum.repos.d/CentOS-Base.repo
</span></span></code></pre></div><p>以阿里云centos服务器为例：
[![img](https://img-blog.csdnimg.cn/20200302133313747.png?#pic_center =500x300)](<a href="https://img-blog.csdnimg.cn/20200302133313747.png?#pic_center">https://img-blog.csdnimg.cn/20200302133313747.png?#pic_center</a> =500x300)</p><h1 id="编辑器">编辑器</h1><h2 id="vim编辑器">vim编辑器</h2><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">PageDown(Ctrl+F):下一页
</span></span><span class="line"><span class="cl">PageUp(Ctrl+B):上一页
</span></span><span class="line"><span class="cl">G：移到最后一行
</span></span><span class="line"><span class="cl">num G：移动第num行
</span></span><span class="line"><span class="cl">gg：移到第一行
</span></span></code></pre></div><p>全选命令：</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">ggVG  # +y 复制,+d删除，
</span></span></code></pre></div><ul><li><strong>vim编辑命令</strong></li></ul><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">x</td><td style="text-align:left">删除当前光标所在位置字符，前面加数字删除多个字符（或者进入插入模式用退格或delete键）</td></tr><tr><td style="text-align:left">dd</td><td style="text-align:left">删除当前光标所在行，前面加数字就可以删除多行</td></tr><tr><td style="text-align:left">dw</td><td style="text-align:left">删除当前光标所在位置单词</td></tr><tr><td style="text-align:left">d$</td><td style="text-align:left">删除当前光标所在位置至行尾内容</td></tr><tr><td style="text-align:left">J</td><td style="text-align:left">删除当前光标所在位置行尾的换行符，用于拼接两行</td></tr><tr><td style="text-align:left">u</td><td style="text-align:left">撤销前一编辑命令</td></tr><tr><td style="text-align:left">a</td><td style="text-align:left">在当前光标后追加数据</td></tr><tr><td style="text-align:left">A</td><td style="text-align:left">在当前光标所在行行尾追加数据</td></tr><tr><td style="text-align:left">r char</td><td style="text-align:left">用char替换当前光标所在位置的单个字符</td></tr><tr><td style="text-align:left">R text</td><td style="text-align:left">用text覆盖当前光标所在位置数据，直到按下ESC键</td></tr></tbody></table><ul><li><strong>复制、粘贴</strong>
剪切：dd之后+p（因为vim在删除数据时，会将其保存在一个单独的寄存器中）
复制：yw复制一个单词，yy复制一行，y$复制到行尾+p粘贴或者进入可视模式（按v）移动光标覆盖你想要复制的文本+p粘贴</li></ul><p>其他的编辑器诸如nano、emacs、KDE、GNOME因为使用不多，因此暂不做记录</p><h1 id="shell脚本编程基础">Shell脚本编程基础</h1><p>所有的shell脚本文件开头第一行需添加</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">#!/bin/bash
</span></span></code></pre></div><p>这告诉shell用哪个shell来运行脚本</p><h2 id="91-echo命令">9.1 echo命令</h2><p>echo可以用来在屏幕打印输出，作用相当于print，下面是一个打印HOME目录和局部环境变量的例子：</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">#!/bin/bash
</span></span><span class="line"><span class="cl">num=10
</span></span><span class="line"><span class="cl">echo "num is $num,home is $HOME"
</span></span></code></pre></div><p>注意在编辑完成后给文件赋予用户可执行命令</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">chmod o+x test.sh
</span></span></code></pre></div><p><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuZ2VudGxlY3AuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy81ZTViYzc2OWYzMGZiLnBuZw?x-oss-process=image/format,png"><img alt="img" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuZ2VudGxlY3AuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy81ZTViYzc2OWYzMGZiLnBuZw?x-oss-process=image/format,png"/></a></p><h2 id="92-命令替换">9.2 命令替换</h2><p>有的时候我们需要将环境变量的输出保存给某个变量，供下一个命令输入，有两种方式实现</p><ul><li><p>反引号</p><p>这个反引号是键盘左上角波浪线一起的那个键，例如date命令可以获取当前时间信息</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">date_variable=`date`
</span></span></code></pre></div></li></ul><p><strong>$()</strong>
shell命令放入括号内</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">date_variable=$(date)
</span></span></code></pre></div><p>下面这个例子是利用date命令创建以日期命名的文件</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">#!/bin/bash
</span></span><span class="line"><span class="cl">today=$(date +%Y-%m-%d)
</span></span><span class="line"><span class="cl">ls test.sh -al &gt; $today.log
</span></span></code></pre></div><p>例子实现了将之前的test.sh shell脚本文件信息输出到一个按今天日期命名的log文件中
[![img](https://img-blog.csdnimg.cn/20200302133403779.png?#pic_center =400x100)](<a href="https://img-blog.csdnimg.cn/20200302133403779.png?#pic_center">https://img-blog.csdnimg.cn/20200302133403779.png?#pic_center</a> =400x100)</p><h2 id="重定向">重定向</h2><p>输出重定向</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">commond &gt; outputfile  # 输出重定向，将命令的输出发送到一个文件中
</span></span><span class="line"><span class="cl">commond &gt;&gt; outputfile  # 追加数据到文件
</span></span></code></pre></div><p>输入重定向</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">wc &lt; test.txt # 通过将文本文件重定向到wc命令，可获得文件的行、词、字节计数
</span></span><span class="line"><span class="cl">wc &lt;&lt; EOF # 内联重定向，记录下面输入的内容，直到输入EOF（或者内联的任意结束标志），输出统计的行、词、字节计数
</span></span></code></pre></div><p>可以利用输入输出重定向来实现将一个命令的输出作为另一个命令的输入</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">commond1 &gt; commond.list
</span></span><span class="line"><span class="cl">commond2 &lt; commond.list
</span></span></code></pre></div><h2 id="管道">管道</h2><p>可以用管道实现上述两次重定向相同的功能</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">command1 | command2  # 两个命令会同时运行，在第一个命令产生输出结果时立刻送给第二个命令
</span></span></code></pre></div><p>比较常见的是将ls-l的输出输送到more，实现大量数据翻页查看</p><h2 id="数学计算">数学计算</h2><p>在bash中，将一个数学运算结果赋给某个变量时，采用$[opreation]的形式</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">var = $[2 * 8]  # 建议采用这种方式，因为这样*不会被理解为正则通配符
</span></span></code></pre></div><p>不过bash仅能支持整数运算，所以不太建议用shell脚本做数学运算，如果非用不可就利用内建bash计算器bc</p><h2 id="命令退出状态码">命令退出状态码</h2><p>每个命令在结束退出的时候都会返回给Linux系统一个状态码，告诉其自己的运行状况。正常退出的状态码为0，其余为正整数，下面是一个例子：</p><p>[![img](https://img-blog.csdnimg.cn/20200302133422113.png#pic_center =400x100)](<a href="https://img-blog.csdnimg.cn/20200302133422113.png#pic_center">https://img-blog.csdnimg.cn/20200302133422113.png#pic_center</a> =400x100)</p><p>下面是Linux的退出状态码表</p><table><thead><tr><th style="text-align:left">状态码</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">成功退出</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">一般性未知错误，例如无效参数</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">不适合的shell命令</td></tr><tr><td style="text-align:left">126</td><td style="text-align:left">命令不可执行，即用户没有权限执行命令</td></tr><tr><td style="text-align:left">127</td><td style="text-align:left">没找到命令</td></tr><tr><td style="text-align:left">128</td><td style="text-align:left">无效的退出参数</td></tr><tr><td style="text-align:left">128+x</td><td style="text-align:left">与Linux信号x相关的严重错误</td></tr><tr><td style="text-align:left">130</td><td style="text-align:left">通过Ctrl+C终止的命令</td></tr><tr><td style="text-align:left">255</td><td style="text-align:left">正常范围之外的退出状态码</td></tr></tbody></table><p>默认情况下，shell脚本以最后一个命令的退出状态码退出，但我们可以通过exit命令指定一个退出状态码</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">exit 5   # 以一个正整数作为退出状态码
</span></span><span class="line"><span class="cl">exit $var   # 以一个变量作为退出状态码，如果变量大于255，则会返回模255
</span></span></code></pre></div><h1 id="结构化命令">结构化命令</h1><p>前面所讲的shell脚本命令都是按照顺序执行，这难以满足现实开发的需求，这节介绍了一些特殊语句，用于丰富我们的脚本</p><h2 id="if-then语句">if-then语句</h2><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">if command   # if 执行command，如果该退出码是0则执行then，否在不执行then后面的命令
</span></span><span class="line"><span class="cl">then
</span></span><span class="line"><span class="cl">    commands
</span></span><span class="line"><span class="cl">fi
</span></span></code></pre></div><p>下面是一个例子，包括正确执行then和不执行then</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">#!/bin/bash
</span></span><span class="line"><span class="cl"># execute then
</span></span><span class="line"><span class="cl">if pwd
</span></span><span class="line"><span class="cl">then
</span></span><span class="line"><span class="cl">    echo "pwd has been successfully executed"
</span></span><span class="line"><span class="cl">fi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#!/bin/bash
</span></span><span class="line"><span class="cl"># don't execute then
</span></span><span class="line"><span class="cl">if xxxx
</span></span><span class="line"><span class="cl">then
</span></span><span class="line"><span class="cl">    echo "pwd has been successfully executed"
</span></span><span class="line"><span class="cl">fi
</span></span></code></pre></div><p>正确执行结果</p><p><a href="https://img-blog.csdnimg.cn/20200302133439748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dlbnRsZUNQ,size_16,color_FFFFFF,t_70"><img alt="img" src="https://img-blog.csdnimg.cn/20200302133439748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dlbnRsZUNQ,size_16,color_FFFFFF,t_70"/></a></p><p>未执行结果</p><p><a href="https://img-blog.csdnimg.cn/20200302133449798.png"><img alt="img" src="https://img-blog.csdnimg.cn/20200302133449798.png"/></a></p><h2 id="if-then-else语句">if-then-else语句</h2><p>与if-then类似，只是多了else分支，在then不执行时执行else中的命令</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">if command
</span></span><span class="line"><span class="cl">then
</span></span><span class="line"><span class="cl">    commands
</span></span><span class="line"><span class="cl">else
</span></span><span class="line"><span class="cl">    commands
</span></span></code></pre></div><h2 id="嵌套if语句elif">嵌套if语句，elif</h2><p>上述方法能够判断的条件仅一次，可以通过if嵌套的方式进行多次判断，但是这样代码显得杂乱无章，此时可以通过elif进行第二次判断，下面是一个例子</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">#!/bin/bash
</span></span><span class="line"><span class="cl"># test if-then-elif-then-else
</span></span><span class="line"><span class="cl">#
</span></span><span class="line"><span class="cl">user=gentlecp
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">if grep $user /etc/passwd
</span></span><span class="line"><span class="cl">then
</span></span><span class="line"><span class="cl">    echo "User: $user exists on this system"
</span></span><span class="line"><span class="cl">elif ls -d /home/$user
</span></span><span class="line"><span class="cl">then
</span></span><span class="line"><span class="cl">    echo "User: $user doesn't exist on this system"
</span></span><span class="line"><span class="cl">    echo "However, $user has a directory at /home"
</span></span><span class="line"><span class="cl">else
</span></span><span class="line"><span class="cl">    echo "User: $user doesn't exist on this system"
</span></span><span class="line"><span class="cl">    echo "Moreover, $user doesn't have a directory at /home"
</span></span><span class="line"><span class="cl">fi
</span></span></code></pre></div><p>在这个脚本中，elif接过if后命令状态码不为0的情况再次做了判断，下面的elif-then-else 是一个整体，相当于一个独立的if-then-else，不过已经获知了if后语句执行失败的消息
<strong>运行结果：</strong>
1、没有User gentlecp</p><p><a href="https://img-blog.csdnimg.cn/20200302133509565.png"><img alt="img" src="https://img-blog.csdnimg.cn/20200302133509565.png"/></a><a href="https://img-blog.csdnimg.cn/202003021335229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dlbnRsZUNQ,size_16,color_FFFFFF,t_70"><img alt="img" src="https://img-blog.csdnimg.cn/202003021335229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dlbnRsZUNQ,size_16,color_FFFFFF,t_70"/></a></p><p>2、创建/home/gentlecp目录运行</p><p><a href="https://img-blog.csdnimg.cn/202003021335229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dlbnRsZUNQ,size_16,color_FFFFFF,t_70"><img alt="img" src="https://img-blog.csdnimg.cn/202003021335229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dlbnRsZUNQ,size_16,color_FFFFFF,t_70"/></a></p><h2 id="case语句">case语句</h2><p>有的时候大量的elif非常冗长，且可读性差，这时可用case语句来替换elif，case语句的模式如下</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">case variable in
</span></span><span class="line"><span class="cl">pattern1 | pattern2) commands 1;;  # 注意要有两个分号
</span></span><span class="line"><span class="cl">pattern3) commands 2;;
</span></span><span class="line"><span class="cl">*) default commands;;
</span></span></code></pre></div><h2 id="test命令">test命令</h2><p>目前if-then语句中均是判断退出状态码，无法测试命令退出状态码以外的条件（事实上也是如此），但可以通过test命令来提供测试不同条件，如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0，否则返回非0状态码</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">if test condition
</span></span><span class="line"><span class="cl">then
</span></span><span class="line"><span class="cl">    commands
</span></span><span class="line"><span class="cl">fi
</span></span></code></pre></div><p>下面是一个测试变量中是否存在内容的例子</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">#!/bin/bash
</span></span><span class="line"><span class="cl"># test the test command
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">variable="ojbk"
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">if test $variable
</span></span><span class="line"><span class="cl">then
</span></span><span class="line"><span class="cl">    echo "variable has something"
</span></span><span class="line"><span class="cl">else
</span></span><span class="line"><span class="cl">    echo "variable has nothing"
</span></span><span class="line"><span class="cl">fi
</span></span></code></pre></div><p><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuZ2VudGxlY3AuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy81ZTViYzgwNmQ1MmQxLnBuZw?x-oss-process=image/format,png"><img alt="img" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuZ2VudGxlY3AuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy81ZTViYzgwNmQ1MmQxLnBuZw?x-oss-process=image/format,png"/></a></p><p>但是如果你直接用if判断该条件就会如下</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">#!/bin/bash
</span></span><span class="line"><span class="cl"># test the test command
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">variable="ojbk"
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">if $variable
</span></span><span class="line"><span class="cl">then
</span></span><span class="line"><span class="cl">    echo "variable has something"
</span></span><span class="line"><span class="cl">else
</span></span><span class="line"><span class="cl">    echo "variable has nothing"
</span></span><span class="line"><span class="cl">fi
</span></span></code></pre></div><p><a href="https://img-blog.csdnimg.cn/20200302133547421.png"><img alt="img" src="https://img-blog.csdnimg.cn/20200302133547421.png"/></a></p><p>很明显if 获得$variable命令的退出码非零
如果你不想使用test命令也可以通过添加[]的方式，个人比较喜欢加[]的方式更清爽</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">if [ condition ]  # 注意[]里condition与两边的一个空格不能省
</span></span><span class="line"><span class="cl">then
</span></span><span class="line"><span class="cl">    commands
</span></span><span class="line"><span class="cl">fi
</span></span></code></pre></div><p>test命令可以判断三类条件：1、数值比较 2、字符串比较 3、文件比较</p><hr/><p>有几点需要特别说明的地方
（1）对于字符串大小比较
字符串大小比较中，直接用&gt;,&lt;会变成重定向，需要加上转义符<br/>下表记录了三类条件的比较功能</p><table><thead><tr><th><strong>条件</strong></th><th><strong>比较</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>数值</td><td>n1 -eq n2</td><td>n1是否等于n2）</td></tr><tr><td>n1 -ge n2</td><td>n1是否大于等于n2</td><td></td></tr><tr><td>n1 -gt n2</td><td>n1是否大于n2</td><td></td></tr><tr><td>n1 -le n2</td><td>n1是否小于等于n2</td><td></td></tr><tr><td>n1 -lt n2</td><td>n1是否小于n2</td><td></td></tr><tr><td>n1 -ne n2</td><td>n1是否不等于n2</td><td></td></tr><tr><td>字符串</td><td>str1 = str2</td><td>str1是否同于str2</td></tr><tr><td>str1 != str2</td><td>str1是否不同于str2</td><td></td></tr><tr><td>str1 &lt; str2</td><td>str1是否小于str2(需加\转义符)</td><td></td></tr><tr><td>str1 &gt; str2</td><td>str1是否大于str2(需加\转义符)</td><td></td></tr><tr><td>-n str1</td><td>str1长度是否非0</td><td></td></tr><tr><td>-z str1</td><td>str1长度是否为0</td><td></td></tr><tr><td>文件</td><td>-d file</td><td>检查file是否存在且为目录</td></tr><tr><td>-e file</td><td>检查file是否存在</td><td></td></tr><tr><td>-f file</td><td>检查file是否存在且是一个文件</td><td></td></tr><tr><td>-r file</td><td>检查file是否存在且可读</td><td></td></tr><tr><td>-w file</td><td>检查file是否存在且可写</td><td></td></tr><tr><td>-x file</td><td>检查file是否存在且可执行</td><td></td></tr><tr><td>-s file</td><td>检查file是否存在且非空</td><td></td></tr><tr><td>-O file</td><td>检查file是否存在且属当前用户所有</td><td></td></tr><tr><td>-G file</td><td>检查file是否存在且默认组与当前用户相同</td><td></td></tr><tr><td>file1 -nt file2</td><td>检查file1是否比file2新</td><td></td></tr><tr><td>file -ot file2</td><td>检查file1是否比file2旧</td><td></td></tr></tbody></table><h2 id="if-then高级特性">if-then高级特性</h2><ul><li><p><strong>双括号用于高级数学表达式</strong>
之前的数学表达式都是简单的判断大小，仅一个数学符号，双括号支持更复杂的数学表达式</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">((expression))  # $val ** 2 &gt;100 
</span></span></code></pre></div></li></ul><p><strong>双方括号针对字符串</strong>
双方括号用于字符串的时候，相当于做模式匹配</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-text" data-lang="text"><span class="line"><span class="cl">[[expression]]  # $USER == test* ,==对左边进行右边的pattern进行模式匹配
</span></span></code></pre></div><hr/><p>转载：https://blog.gentlecp.com/article/48940.html</p></div><div class="post_footer"><div class="meta"><div class="info"><span class="field tags"><i class="ri-stack-line"></i>
<a href="https://zozo.wssss.one/tags/linux/">Linux</a>
<a href="https://zozo.wssss.one/tags/%E6%8A%80%E6%9C%AF/">技术</a>
<a href="https://zozo.wssss.one/tags/%E8%BD%AC%E8%BD%BD/">转载</a></span></div></div></div></div><script async="" crossorigin="anonymous" data-category="General" data-category-id="DIC_kwDOIgezUM4CTB6g" data-emit-metadata="0" data-input-position="top" data-lang="zh-CN" data-loading="lazy" data-mapping="pathname" data-reactions-enabled="1" data-repo="winsight/hugo_zozo_comment" data-repo-id="R_kgDOIgezUA" data-strict="0" data-theme="light" src="https://giscus.app/client.js"></script></div></div></div><a class="back_to_top" href="#" id="back_to_top"><i class="ri-arrow-up-s-line"></i></a><footer class="footer"><div class="powered_by"><a href="https://timegg.top">SSWIN © 2022 ,</a>
<a href="http://www.gohugo.io/">Powered by Hugo.</a></div><div class="footer_slogan"><span>享受当下。</span></div></footer><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@500;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><script src="https://zozo.wssss.one/js/jquery-3.5.1.min.js"></script>
<link href="https://zozo.wssss.one/css/fancybox.min.css" rel="stylesheet"/><script src="https://zozo.wssss.one/js/fancybox.min.js"></script>
<script src="https://zozo.wssss.one/js/zozo.js"></script></body></html>